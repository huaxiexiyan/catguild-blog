[{"content":" ","permalink":"https://www.catguild.cn/category/redis/readme/","summary":" ","title":""},{"content":"记一次生产事故 事故情景\n表现\n解决\n原因\n复盘\n","permalink":"https://www.catguild.cn/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1durid%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AF%BC%E8%87%B4%E7%9A%84%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85/","summary":"记一次生产事故 事故情景 表现 解决 原因 复盘","title":""},{"content":"这里是这篇文章的源文件：\n测试各种样式的帖子哦\n上面是分割线，看到了么？\n段内格式测试： 这里首先是紧接着的一段而不分行。然后是粗体和斜体，粗斜体，以及删除线和段内代码，最后就是注脚1。\n下划线生成标题：\n下划线标题1 下划线标题2 #Sharp标题1\n##Sharp标题2\n###Sharp标题3\n####Sharp标题4\n#####Sharp标题5\n######Sharp标题6\n\u0026lsquo;\u0026gt;\u0026lsquo;导出的引用代码块 段内分行\n两行结束代码块\n引用块内样式：粗体，斜体，粗斜体，删除线，段内代码。 第二用\u0026rsquo;\u0026gt;\u0026lsquo;继续引用块\n双重引用块\n代码引用：\n四个空格的方式 一换行就没了\n[```] //不要这里的中括号哦。。。 fence的方式 这个方式不怕换行\n怎么换都可以。\n这里不能使用别的样式：粗体，斜体，删除线，超链接 [```] //不要这里的中括号哦。。。\n列表：\n有序列表1 有序列表2 - 子列表1 - 子列表2 * 子子列表1 * 子子列表2 1. 子子子列表1 1. 子子子列表2 1. 子子子列表3 * 子子列表3 - 子列表3 有序列表3 有序列表4 无序列表1 无序列表2 无序列表3 无序列表4 测试超链接：直接适用URL和使用引用URL\n接着是图片： 和引用式的用法： 表格：\nA B C A1 B1 C1 A2 B2 C2 这是普通表格\n左对齐 剧中 右对齐 A1 B1 C1 A2 B2 C2 这是文艺表格\nA B C 粗体 斜体 删除 __另一种粗体__A2 另一个斜体 段内代码 超链接也可以 脚注2 这是二逼表格\n接下来是sanitize部分：\np标签的使用\nblockquote标签的使用 pre标签 code标签\npre和code 下面试试列表们\n有序列表1 有序列表2 子列表1 子列表2 子子列表1 子子列表2 子子子列表1 子子子列表2 子子列表3 子列表1 有序列表3 格式： B粗体和STRONG粗体 I斜体和EM斜体 U下划线和STRIKE删除线与STRIKE删除线 超链接，CITE标记，CAPTION标题 普通文字SUP上标SUB下标BIG加大SMALL减小 带尺寸的IMAGE 嗯，常用的基本就这些了。\n这个就是注脚内容，写在文章最后\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这个是第二条注脚内容，写在文章里面\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://www.catguild.cn/posts/markdown%E8%AF%AD%E6%B3%95%E6%B5%8B%E8%AF%95/","summary":"这里是这篇文章的源文件： 测试各种样式的帖子哦 上面是分割线，看到了么？ 段内格式测试： 这里首先是紧接着的一段而不分行。然后是粗体和斜体，粗斜体，以及删除线和段内代码，最后就是注脚1。 下划线生成标题： 下划线标题1 下划线标题2 #Sharp标题1 ##","title":"markdown语法效果测试"},{"content":"基本安装 1、到官网下载最新的版本\n虚拟环境 1、安装\npip install pipenv 2、（选用）修改环境变量 该环境会让虚拟环境创建再当前项目下，否则会创建默认位置\nPIPENV_VENV_IN_PROJECT=1 3、到项目目录下\npipenv install 该命令会创建虚拟环境目录，并生成 Pipfile 和Pipfile.lock 文件\n4、安装依赖\npipenv install package_name 5、国内源\n阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ ","permalink":"https://www.catguild.cn/category/practical/python/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"基本安装 1、到官网下载最新的版本 虚拟环境 1、安装 pip install pipenv 2、（选用）修改环境变量 该环境会让虚拟环境创建再当前项目下，否则会创建默认位置 PIPENV_VENV_IN_PROJECT=1 3、到项目目录下 pipenv install 该命令会创建虚拟环境目录，并生成 Pipfile 和Pipfile.lock 文件 4、安装依赖 pipenv install package_name 5、","title":"Python基本使用"},{"content":"为什么需要分布式锁 单机场景下用的都是本地锁，针对的仅仅是一个jvm进程所管理的资源。当单体应用部署了多份的时候，一个jvm进程中本地锁是无法影响到另一个jvm进程的本地锁的，这样是无法保证资源的独占的。所以分布式锁应运而生。\n一个靠谱的分布式锁需要具备哪些条件 首先需要考虑一个合格的分布式锁需要具备哪些条件。 一个锁需要具备的基本功能 1、独占性：任何时候都仅能有一个线程获取该锁。这是任何一个锁最基础的功能，毕竟锁就是为了解决资源竞争产生的不一致问题。 2、不乱抢：当前线程加的锁，只能有当前线程来解锁，也不能去unlock其它线程加的锁。 3、可重入性：在当前线程中，如果已经获取了该锁，之后将可以自动再次获取这个锁。 在分布式环境需要额外考虑的问题 1、防止死锁：要能杜绝死锁，要有兜底方案，例如能支持撤销操作或者可以超时自动释放 2、高可用：性能要好，能支撑高并发请求，不能因为某节点不可用，就导致获取锁或者释放失败\n如果自己来实现一个分布式锁该如何做 自然是围绕了如何实现上面靠谱的分布式锁具备的条件了。\n前置准备工作 1、选择外部存储介质 因为需要让不同的jvm进程都能访问到存放锁的资源点，那么就需要依赖jvm外部的存储介质了。一般来说就是 数据库（关系型或nosql）、微服务里的配置中心（支持多个服务来读存数据）。那么这里就先用目前最常用的nosql数据库 Redis 为例来实现了。 2、代码实现规范 分布式锁必然有多种实现方式，那自然应该是基于接口来编程，那么直接实现jdk中的lock接口就是最好的方式。\n测试准备 准备一个多实例，支持并发请求的测试环境，来验证是否代码是否通过。\n分步来实现分布式锁应具备的功能 1、独占性 只需要在存储介质上留下个锁标记即可，如果其他线程能查询到这个标识，那就说明该资源已经上锁，否则则表示无锁，可以上锁。\n有什么成熟的解决方案 需要注意些什么 ","permalink":"https://www.catguild.cn/category/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","summary":"为什么需要分布式锁 单机场景下用的都是本地锁，针对的仅仅是一个jvm进程所管理的资源。当单体应用部署了多份的时候，一个jvm进程中本地锁是无法影响到另一个jvm进程的本地锁的，这样是无法保证资源的独占的。所以分布式锁应运而生。 一个靠谱的分布式","title":"Redis分布式锁"},{"content":"页面内容2 ","permalink":"https://www.catguild.cn/category/redis/redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"页面内容2","title":"Redis基础数据类型"},{"content":"1、Redis除了拿来做缓存\n","permalink":"https://www.catguild.cn/category/redis/redis%E9%9D%A2%E8%AF%95%E9%A2%98/","summary":"1、Redis除了拿来做缓存","title":"Redis面试题"},{"content":"初认识 基本用于 三种触发器 实际运行一下 import lombok.extern.slf4j.Slf4j; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; /** * @author xiyan * @date 2023/7/5 14:36 */ @Slf4j @EnableScheduling @Component public class DemoScheduledTest { /** * 固定延迟时间 * 间隔 5s ，执行 3s、实际间隔8s * 2023-07-06 17:36:05.068 * 2023-07-06 17:36:13.091 * 2023-07-06 17:36:21.109 * 2023-07-06 17:36:29.134 * 2023-07-06 17:36:37.149 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 5s、实际间隔10s * 2023-07-05 14:38:46.182 * 2023-07-05 14:38:56.196 * 2023-07-05 14:39:06.210 * 2023-07-05 14:39:16.235 * 2023-07-05 14:39:26.244 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 7s、实际间隔12s * 2023-07-05 14:45:02.764 * 2023-07-05 14:45:14.775 * 2023-07-05 14:45:26.796 * 2023-07-05 14:45:38.814 * 2023-07-05 14:45:50.830 * \u0026lt;p\u0026gt; * 下次执行时间=上次执行时间+(fixedDelay时间+执行耗时) */ @Scheduled(fixedDelay = 5000) public void test1() { try { log.info(\u0026#34;test1方法执行=====\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34;); Thread.sleep(3000); } catch (InterruptedException e) { throw new RuntimeException(e); } } /** * 固定间隔时间 * 间隔5s、执行3s、实际间隔5s * 2023-07-06 18:00:11.362 * 2023-07-06 18:00:16.352 * 2023-07-06 18:00:21.358 * 2023-07-06 18:00:26.355 * 2023-07-06 18:00:31.364 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 5s、实际间隔5s * 2023-07-05 14:40:39.180 * 2023-07-05 14:40:44.185 * 2023-07-05 14:40:49.200 * 2023-07-05 14:40:54.212 * 2023-07-05 14:40:59.226 * \u0026lt;p\u0026gt; * 间隔5s，执行7s、实际间隔7s * 2023-07-05 14:41:45.559 * 2023-07-05 14:41:52.567 * 2023-07-05 14:41:59.581 * 2023-07-05 14:42:06.588 * 2023-07-05 14:42:13.593 * \u0026lt;p\u0026gt; * 下次执行时间=上次执行时间+ max(fixedRate, 执行耗时) */ @Scheduled(fixedRate = 5000) public void test2() { try { log.info(\u0026#34;test2方法执行=====\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34;); Thread.sleep(3000); } catch (InterruptedException e) { throw new RuntimeException(e); } } /** * cron表达式 * \u0026lt;p\u0026gt; * 间隔5s、执行3s、实际间隔5s * 2023-07-06 17:55:10.015 * 2023-07-06 17:55:15.001 * 2023-07-06 17:55:20.014 * 2023-07-06 17:55:25.007 * 2023-07-06 17:55:30.008 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 5s、实际间隔10s * 2023-07-06 17:49:55.008 * 2023-07-06 17:50:05.014 * 2023-07-06 17:50:15.000 * 2023-07-06 17:50:25.004 * 2023-07-06 17:50:35.005 * \u0026lt;p\u0026gt; * 间隔5s，执行7s、实际间隔10s * 2023-07-06 17:51:55.016 * 2023-07-06 17:52:05.008 * 2023-07-06 17:52:15.001 * 2023-07-06 17:52:25.010 * 2023-07-06 17:52:35.014 * \u0026lt;p\u0026gt; * 下次执行时间=如果到达定时时间，上一个任务已完成，将会执行，否则会跳过 */ @Scheduled(cron = \u0026#34;0/5 * * * * ?\u0026#34;) public void test3() { try { log.info(\u0026#34;test3方法执行=====\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34;); Thread.sleep(5000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } 为什么会这样 运行原理 拓展应用 ","permalink":"https://www.catguild.cn/posts/spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","summary":"初认识 基本用于 三种触发器 实际运行一下 import lombok.extern.slf4j.Slf4j; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; /** * @author xiyan * @date 2023/7/5 14:36 */ @Slf4j @EnableScheduling @Component public class DemoScheduledTest { /** * 固定延迟时间 * 间隔 5s ，执行 3s、实际间隔8s * 2023-07-06 17:36:05.068 * 2023-07-06 17:36:13.091 * 2023-07-06 17:36:21.109 * 2023-07-06 17:36:29.134 * 2023-07-06 17:36:37.149 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 5s、实际间隔10s * 2023-07-05 14:38:46.182 * 2023-07-05 14:38:56.196 * 2023-07-05 14:39:06.210 * 2023-07-05 14:39:16.235 * 2023-07-05 14:39:26.244 * \u0026lt;p\u0026gt; * 间隔","title":"Spring定时任务"},{"content":"","permalink":"https://www.catguild.cn/about/","summary":"","title":"关于"},{"content":"CDN 含义 内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\u0026mdash;引用自维基百科\nCDN 服务 CDN服务类似服务器的租赁服务，这些服务器一般都是CDN服务商的数据中心，这些服务器可以缓存我们的网站资源，类似一种高速缓存。但是我们无法直接登录这些服务器，但是可以设置一些服务商开放出来的数据管理策略，比如\n静态资源压缩，减小资源传输体积，以提高传输速度和带宽利用率，最常见的压缩方案包括gzip和Brotli。 缓存策略，指定缓存的资源及缓存过期时间，以提供响应速度，并且降低了源服务器的访问压力。 安全策略，用以防止链接盗用，一般的CDN服务都是要付费的，可以设置安全策略，来访问其他人来使用你的CDN服务 CDN工作流程 终端访问CDN加速域名 DNS服务解析CNAME记录（实际上就是获取CDN服务商的服务器地址，此时会返回一个里终端最近的服务器地址） 终端去访问DNS服务器返回的目标服务器地址 CDN服务器检查是否存在该资源 4-1. 如果存在则直接返回该资源 4-2. 如果不存在，则前往回源地址或回源host获取该资源，然后将其返回给终端 如何利用好CDN服务 现在我们知道了CDN服务，实际就是在实际的资源机之间加了一个缓冲集群。终端将不再之间访问我们的资源机，而是是访问这个缓冲集群。如果访问到的节点中没有目标资源，该节点才会去资源机去拉取。故，要提高CDN服务的利用，就是要减少这个拉取动作，也可以说是回源率。另一方面，回源是难以避免的，所有提高回源效率，也会优化的访问速度。\n降低回源率：一般就是采用服务商提供的缓存机制，而要利用好缓存，就需要对资源站尽可能的静态化。 提高回源效果：对一些静态资源的访问，进行合并压缩处理，以减少访问次数，资源传输体积；或者提高资源站的带宽（这点可能会比较难，其实CDN的目的就是在带宽不变的前提下提高更快的访问服务） 其实总结起来就是，缓存+减少数据传输量+减少访问次数 而这三条，在CDN服务商提供的缓冲集群能做，在自己的资源机上也能做。这样就能尽可能的加快资源机的资源访问速度。\n参考 Content delivery network - Wikipedia 內容分髮網絡- MBA智库百科 What is a CDN? | How do CDNs work? | Cloudflare CNAME - 百度百科 gzip - 百度百科 HTTP compression\n","permalink":"https://www.catguild.cn/posts/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9Ccnd/","summary":"CDN 含义 内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来","title":"内容分发网络CND"},{"content":" SoulChild随笔记 SoulChild随笔记 ","permalink":"https://www.catguild.cn/links/","summary":"SoulChild随笔记 SoulChild随笔记","title":"友链"},{"content":"爬虫框架 scrapy 1、创建新项目\nscrapy startproject tutorial 2、创建爬虫文件\n# 创建普通模版 scrapy genspider 爬虫名字 爬取的域名（不用协议头） # 创建 crawl spider 模版 scrapy genspider -t crawl 爬虫名字 爬取的域名（不用协议头） 3、启动爬虫\nscrapy crawl 爬虫名字 项目文件结构 项目名字 项目名字 spiders文件夹（存储的是爬虫文件） init 自定义的爬虫文件\t核心功能文件 init items\t定义数据结构的地方\t爬取的数据包含那些 middleware\t中间件\t代理 settings\t配置文件\trobots协议\tua定义等 response的属性和方法 response.text\t获取的是响应的字符串 response.body\t获取的是二进制数据 response.xpath\t可以直接是xpath方法来解析response中的内容 response.extract()\t提取seletor对象的data属性值 response.extract_first()\t提取seletor列表的第一个数据 setting # 需要使用管道，需要打开该设置 ITEM_PIPELINES = { # 管道可以有多个，并有有优先级，值从1-1000，值越小越高 \u0026#39;项目名.pipelines.管道名\u0026#39;: 300 } 下载图片 import urllib.request class DownLoadPipeline: def process_item(self, item, spider): url = item.get(\u0026#39;url\u0026#39;) filename=\u0026#39;http://\u0026#39;+ item.get(\u0026#39;name\u0026#39;)+\u0026#39;.jpg\u0026#39; urllib.request.urlretrieve(url = url, filename = filename) return item 部署 scrapy部署服务器有一套完整的开源项目：scrapy+scrapyd(服务端)+scrapy-client(客户端)+scrapydweb 1、scrapyd(服务端)\n# 官方文档 https://scrapyd.readthedocs.io # 安装 pipenv install scrapyd # 启动 scrapyd # 浏览器访问 http://127.0.0.1:6800 2、scrapy-client scrapy-client它允许我们将本地的scrapy项目打包发送到scrapyd 这个服务端（前提是服务器scrapyd正常运行）\n# 官方文档 https://pypi.org/project/scrapyd-client/ # 安装 pipenv install scrapyd-client 3、scrapydweb（可选）\nScrapydWeb：用于Scrapyd集群管理的Web应用程序，支持Scrapy日志分析和可视化。\n#官方文档 https://github.com/my8100/scrapydweb/blob/master/README_CN.md # 安装 pipenv install scrapydweb # 运行命令 scrapydweb 运行命令scrapydweb，首次启动将会在当前目录下生成配置文件“scrapydweb_settings_v*.py”\n1、更改配置文件 编辑配置文件，将ENABLE_LOGPARSER更改为False\n2、添加访问权限\nSCRAPYD_SERVERS = [ \u0026#39;127.0.0.1:6800\u0026#39;, # \u0026#39;username:password@localhost:6801#group\u0026#39;, (\u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;6801\u0026#39;, \u0026#39;group\u0026#39;), ] 3、添加http认证\nENABLE_AUTH = True USERNAME = \u0026#39;username\u0026#39; PASSWORD = \u0026#39;password\u0026#39; 如果启动失败（一般是使用了高版本的python） # 400 错误 APScheduler==3.9.1 # 500 错误 SQLAlchemy\u0026gt;=1.2.15,\u0026lt;1.4.0 ","permalink":"https://www.catguild.cn/category/practical/python/%E7%88%AC%E8%99%AB/","summary":"爬虫框架 scrapy 1、创建新项目 scrapy startproject tutorial 2、创建爬虫文件 # 创建普通模版 scrapy genspider 爬虫名字 爬取的域名（不用协议头） # 创建 crawl spider 模版 scrapy genspider -t crawl 爬虫名字 爬取的域名（不用协议头） 3、启动爬虫 scrapy crawl 爬虫名字 项目文件结构 项目名字 项目名字 spiders文件夹（存储的是爬虫文件","title":"爬虫"},{"content":"线程中断机制 LockSupport类 简介：用于创建锁和其他同步类的基本线程阻塞原语\n该类与使用它的每个线程关联一个许可证（在Semaphore类的意义上）。如果许可证可用，将立即返回park，并在此过程中消费；否则可能会阻止。如果尚未提供许可，则致电unpark获取许可（与Semaphore不同，许可证不会累积，最多只有一个）\n主要api：park与unpark方法，需要成对使用。\npark：除非许可证可用，否则禁用当前线程以进行线程调度。【作用：阻塞线程】\nunaprk：如果给定线程尚不可用，则为其提供许可。【作用：解除阻塞线程】\n底层调用的是unsafe类，\n使用场景：\n线程阻塞唤醒的方法 有3种方式\n1、使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程\n2、使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程\n3、 LockSupport类可以阻塞当前线程以及唤醒指定被阻塞线程\n线程等待唤醒机制 ","permalink":"https://www.catguild.cn/category/juc/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/","summary":"线程中断机制 LockSupport类 简介：用于创建锁和其他同步类的基本线程阻塞原语 该类与使用它的每个线程关联一个许可证（在Semaphore类的意义上）。如果许可证可用，将立即返回park，并在此过程中消费；否则可能会阻止。如果尚未提供许可","title":"线程中断"}]