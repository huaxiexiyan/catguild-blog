[{"content":" ","permalink":"https://www.catguild.cn/category/redis/readme/","summary":" ","title":""},{"content":"记一次生产事故 事故情景\n表现\n解决\n原因\n复盘\n","permalink":"https://www.catguild.cn/posts/%E8%AE%B0%E4%B8%80%E6%AC%A1durid%E6%95%B0%E6%8D%AE%E6%BA%90%E5%AF%BC%E8%87%B4%E7%9A%84%E7%94%9F%E4%BA%A7%E4%BA%8B%E6%95%85/","summary":"记一次生产事故 事故情景 表现 解决 原因 复盘","title":""},{"content":"protobuf语法 文件格式\n.proto 版本设定\n# 可选proto2 ，主流一般都是用 proto3 syntax = \u0026#34;proto3\u0026#34;; 注释\n单行 # 多行 /* */ 与java语言相关的语法\n# 后续 protobuf 生成的java代码，是在同一源文件，还是多个源文件中 option java_multiple_files = true; # 指定 protobuf 生成的类 放在什么包下面 option java_package = \u0026#34;com.xx.xx\u0026#34;; # 指定 protobuf 生成的外部类的名字（管理内部类【内部类才是真正开发使用的】） option java_outer_classname = \u0026#34;HelloWorldService\u0026#34;; 逻辑包（了解，一般不用）\n# 对于 protobuf 对于文件内容的管理 package xxx; 导入其他 proto 文件\nUserService.proto OrderService.proto import \u0026#34;xxx/UserService.proto\u0026#34;; 基本类型\n枚举类型\n消息message\nmessage LoginRequest { string username = 1; singular string password = 2; int32 age = 3; } // 编号 从 1 - 2^29-1 ；注意：19000 - 19999 不能用这个区间内的编号，因为这个是 protobuf 的保留编号 // - singular : 这个字段的值只能是 0 或 1 个（默认关键字） null // - repeated message Result { string content = 1; repeated string status = 2; // 这个字段返回值是多个，等价于 java list protobuf getStatusList() -\u0026gt; list } 服务\nservice HelloService{ rpc hello(HelloRequest) returns(HelloReponse){} } # 里面可以定义多个服务方法 # 定义多个服务接口 # gRPC 服务 4 种服务方式 第一个 gRPC 服务 项目结构\n1. xxx-api 模块 定义 protobuf idl语言 并通过命令创建具体的代码，后续 client server 引入依赖使用 1. message 消息定义 2. service 服务定义 2. xxx-server 模块 1. 实现 api 模块中定义的服务接口 2. 发布 gRPC 服务 （创建服务端程序） 3. xxx-client 模块 1. 创建服务端 stub（代理） 2. 基于代理 stub 进行 RPC 调用 xxx-server 服务端模块的开发\n1. 实现服务接口 ","permalink":"https://www.catguild.cn/posts/gprc/","summary":"protobuf语法 文件格式 .proto 版本设定 # 可选proto2 ，主流一般都是用 proto3 syntax = \u0026#34;proto3\u0026#34;; 注释 单行 # 多行 /* */ 与java语言相关的语法 # 后续 protobuf 生成的java代码，是在同一源文件，还是多个源文件中 option java_multiple_files = true; # 指定 protobuf 生成的类 放在什么包下面 option java_package = \u0026#34;com.xx.xx\u0026#34;; # 指定 protobuf 生成","title":"gRPC"},{"content":"这里是这篇文章的源文件：\n测试各种样式的帖子哦\n上面是分割线，看到了么？\n段内格式测试： 这里首先是紧接着的一段而不分行。然后是粗体和斜体，粗斜体，以及删除线和段内代码，最后就是注脚1。\n下划线生成标题：\n下划线标题1 下划线标题2 #Sharp标题1\n##Sharp标题2\n###Sharp标题3\n####Sharp标题4\n#####Sharp标题5\n######Sharp标题6\n\u0026lsquo;\u0026gt;\u0026lsquo;导出的引用代码块 段内分行\n两行结束代码块\n引用块内样式：粗体，斜体，粗斜体，删除线，段内代码。 第二用\u0026rsquo;\u0026gt;\u0026lsquo;继续引用块\n双重引用块\n代码引用：\n四个空格的方式 一换行就没了\n[```] //不要这里的中括号哦。。。 fence的方式 这个方式不怕换行\n怎么换都可以。\n这里不能使用别的样式：粗体，斜体，删除线，超链接 [```] //不要这里的中括号哦。。。\n列表：\n有序列表1 有序列表2 - 子列表1 - 子列表2 * 子子列表1 * 子子列表2 1. 子子子列表1 1. 子子子列表2 1. 子子子列表3 * 子子列表3 - 子列表3 有序列表3 有序列表4 无序列表1 无序列表2 无序列表3 无序列表4 测试超链接：直接适用URL和使用引用URL\n接着是图片： 和引用式的用法： 表格：\nA B C A1 B1 C1 A2 B2 C2 这是普通表格\n左对齐 剧中 右对齐 A1 B1 C1 A2 B2 C2 这是文艺表格\nA B C 粗体 斜体 删除 __另一种粗体__A2 另一个斜体 段内代码 超链接也可以 脚注2 这是二逼表格\n接下来是sanitize部分：\np标签的使用\nblockquote标签的使用 pre标签 code标签\npre和code 下面试试列表们\n有序列表1 有序列表2 子列表1 子列表2 子子列表1 子子列表2 子子子列表1 子子子列表2 子子列表3 子列表1 有序列表3 格式： B粗体和STRONG粗体 I斜体和EM斜体 U下划线和STRIKE删除线与STRIKE删除线 超链接，CITE标记，CAPTION标题 普通文字SUP上标SUB下标BIG加大SMALL减小 带尺寸的IMAGE 嗯，常用的基本就这些了。\n这个就是注脚内容，写在文章最后\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n这个是第二条注脚内容，写在文章里面\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","permalink":"https://www.catguild.cn/posts/markdown%E8%AF%AD%E6%B3%95%E6%B5%8B%E8%AF%95/","summary":"这里是这篇文章的源文件： 测试各种样式的帖子哦 上面是分割线，看到了么？ 段内格式测试： 这里首先是紧接着的一段而不分行。然后是粗体和斜体，粗斜体，以及删除线和段内代码，最后就是注脚1。 下划线生成标题： 下划线标题1 下划线标题2 #Sharp标题1 ##","title":"markdown语法效果测试"},{"content":"基本安装 1、到官网下载最新的版本\n虚拟环境 1、安装\npip install pipenv 2、（选用）修改环境变量 该环境会让虚拟环境创建再当前项目下，否则会创建默认位置\nPIPENV_VENV_IN_PROJECT=1 3、到项目目录下\npipenv install 该命令会创建虚拟环境目录，并生成 Pipfile 和Pipfile.lock 文件\n4、安装依赖\npipenv install package_name 5、国内源\n阿里云 http://mirrors.aliyun.com/pypi/simple/ 中国科技大学 https://pypi.mirrors.ustc.edu.cn/simple/ 豆瓣(douban) http://pypi.douban.com/simple/ 清华大学 https://pypi.tuna.tsinghua.edu.cn/simple/ 中国科学技术大学 http://pypi.mirrors.ustc.edu.cn/simple/ ","permalink":"https://www.catguild.cn/category/practical/python/%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/","summary":"基本安装 1、到官网下载最新的版本 虚拟环境 1、安装 pip install pipenv 2、（选用）修改环境变量 该环境会让虚拟环境创建再当前项目下，否则会创建默认位置 PIPENV_VENV_IN_PROJECT=1 3、到项目目录下 pipenv install 该命令会创建虚拟环境目录，并生成 Pipfile 和Pipfile.lock 文件 4、安装依赖 pipenv install package_name 5、","title":"Python基本使用"},{"content":"为什么需要分布式锁 单机场景下用的都是本地锁，针对的仅仅是一个jvm进程所管理的资源。当单体应用部署了多份的时候，一个jvm进程中本地锁是无法影响到另一个jvm进程的本地锁的，这样是无法保证资源的独占的。所以分布式锁应运而生。\n一个靠谱的分布式锁需要具备哪些条件 首先需要考虑一个合格的分布式锁需要具备哪些条件。 一个锁需要具备的基本功能 1、独占性：任何时候都仅能有一个线程获取该锁。这是任何一个锁最基础的功能，毕竟锁就是为了解决资源竞争产生的不一致问题。 2、不乱抢：当前线程加的锁，只能有当前线程来解锁，也不能去unlock其它线程加的锁。 3、可重入性：在当前线程中，如果已经获取了该锁，之后将可以自动再次获取这个锁。 在分布式环境需要额外考虑的问题 1、防止死锁：要能杜绝死锁，要有兜底方案，例如能支持撤销操作或者可以超时自动释放 2、高可用：性能要好，能支撑高并发请求，不能因为某节点不可用，就导致获取锁或者释放失败\n如果自己来实现一个分布式锁该如何做 自然是围绕了如何实现上面靠谱的分布式锁具备的条件了。\n前置准备工作 1、选择外部存储介质 因为需要让不同的jvm进程都能访问到存放锁的资源点，那么就需要依赖jvm外部的存储介质了。一般来说就是 数据库（关系型或nosql）、微服务里的配置中心（支持多个服务来读存数据）。那么这里就先用目前最常用的nosql数据库 Redis 为例来实现了。 2、代码实现规范 分布式锁必然有多种实现方式，那自然应该是基于接口来编程，那么直接实现jdk中的lock接口就是最好的方式。\n测试准备 准备一个多实例，支持并发请求的测试环境，来验证是否代码是否通过。\n分步来实现分布式锁应具备的功能 1、独占性 只需要在存储介质上留下个锁标记即可，如果其他线程能查询到这个标识，那就说明该资源已经上锁，否则则表示无锁，可以上锁。\n有什么成熟的解决方案 需要注意些什么 ","permalink":"https://www.catguild.cn/category/redis/redis%E5%88%86%E5%B8%83%E5%BC%8F%E9%94%81/","summary":"为什么需要分布式锁 单机场景下用的都是本地锁，针对的仅仅是一个jvm进程所管理的资源。当单体应用部署了多份的时候，一个jvm进程中本地锁是无法影响到另一个jvm进程的本地锁的，这样是无法保证资源的独占的。所以分布式锁应运而生。 一个靠谱的分布式","title":"Redis分布式锁"},{"content":"页面内容2 ","permalink":"https://www.catguild.cn/category/redis/redis%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/","summary":"页面内容2","title":"Redis基础数据类型"},{"content":"1、Redis除了拿来做缓存\n","permalink":"https://www.catguild.cn/category/redis/redis%E9%9D%A2%E8%AF%95%E9%A2%98/","summary":"1、Redis除了拿来做缓存","title":"Redis面试题"},{"content":"初认识 基本使用 1、添加基本依赖 2、 @EnableScheduling 注解开启定时任务\n@Scheduled 注释标注定时任务方法\n通过注册ScheduledAnnotationBeanPostProcessor来执行@Scheduled注释的处理。这可以手动完成，或者更方便地通过task:annotation-driven/XML元素或@EnableScheduling annotation来完成。\n三种触发器 实际运行一下 import lombok.extern.slf4j.Slf4j; import org.springframework.scheduling.annotation.EnableScheduling; import org.springframework.scheduling.annotation.Scheduled; import org.springframework.stereotype.Component; /** * @author xiyan * @date 2023/7/5 14:36 */ @Slf4j @EnableScheduling @Component public class DemoScheduledTest { /** * 固定延迟时间 * 间隔 5s ，执行 3s、实际间隔8s * 2023-07-06 17:36:05.068 * 2023-07-06 17:36:13.091 * 2023-07-06 17:36:21.109 * 2023-07-06 17:36:29.134 * 2023-07-06 17:36:37.149 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 5s、实际间隔10s * 2023-07-05 14:38:46.182 * 2023-07-05 14:38:56.196 * 2023-07-05 14:39:06.210 * 2023-07-05 14:39:16.235 * 2023-07-05 14:39:26.244 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 7s、实际间隔12s * 2023-07-05 14:45:02.764 * 2023-07-05 14:45:14.775 * 2023-07-05 14:45:26.796 * 2023-07-05 14:45:38.814 * 2023-07-05 14:45:50.830 * \u0026lt;p\u0026gt; * 下次执行时间=上次执行时间+(fixedDelay时间+执行耗时) */ @Scheduled(fixedDelay = 5000) public void test1() { try { log.info(\u0026#34;test1方法执行=====\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34;); Thread.sleep(3000); } catch (InterruptedException e) { throw new RuntimeException(e); } } /** * 固定间隔时间 * 间隔5s、执行3s、实际间隔5s * 2023-07-06 18:00:11.362 * 2023-07-06 18:00:16.352 * 2023-07-06 18:00:21.358 * 2023-07-06 18:00:26.355 * 2023-07-06 18:00:31.364 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 5s、实际间隔5s * 2023-07-05 14:40:39.180 * 2023-07-05 14:40:44.185 * 2023-07-05 14:40:49.200 * 2023-07-05 14:40:54.212 * 2023-07-05 14:40:59.226 * \u0026lt;p\u0026gt; * 间隔5s，执行7s、实际间隔7s * 2023-07-05 14:41:45.559 * 2023-07-05 14:41:52.567 * 2023-07-05 14:41:59.581 * 2023-07-05 14:42:06.588 * 2023-07-05 14:42:13.593 * \u0026lt;p\u0026gt; * 下次执行时间=上次执行时间+ max(fixedRate, 执行耗时) */ @Scheduled(fixedRate = 5000) public void test2() { try { log.info(\u0026#34;test2方法执行=====\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34;); Thread.sleep(3000); } catch (InterruptedException e) { throw new RuntimeException(e); } } /** * cron表达式 * \u0026lt;p\u0026gt; * 间隔5s、执行3s、实际间隔5s * 2023-07-06 17:55:10.015 * 2023-07-06 17:55:15.001 * 2023-07-06 17:55:20.014 * 2023-07-06 17:55:25.007 * 2023-07-06 17:55:30.008 * \u0026lt;p\u0026gt; * 间隔 5s ，执行 5s、实际间隔10s * 2023-07-06 17:49:55.008 * 2023-07-06 17:50:05.014 * 2023-07-06 17:50:15.000 * 2023-07-06 17:50:25.004 * 2023-07-06 17:50:35.005 * \u0026lt;p\u0026gt; * 间隔5s，执行7s、实际间隔10s * 2023-07-06 17:51:55.016 * 2023-07-06 17:52:05.008 * 2023-07-06 17:52:15.001 * 2023-07-06 17:52:25.010 * 2023-07-06 17:52:35.014 * \u0026lt;p\u0026gt; * 下次执行时间=如果到达定时时间，上一个任务已完成，将会执行，否则会跳过 */ @Scheduled(cron = \u0026#34;0/5 * * * * ?\u0026#34;) public void test3() { try { log.info(\u0026#34;test3方法执行=====\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#34;); Thread.sleep(5000); } catch (InterruptedException e) { throw new RuntimeException(e); } } } 为什么会这样 运行原理 /** Bean后处理器，注册用@Scheduled注释的方法，以便由TaskScheduler根据通过注释提供的“fixedRate”、“fixedDelay”或“cron”表达式调用。 这个后处理器由Spring的\u0026lt;task:annotation-driven\u0026gt;XML元素以及@EnableScheduling注释自动注册。 自动检测容器中的任何SchedulingConfigurer实例，允许自定义要使用的计划程序或对任务注册进行细粒度控制（例如，注册触发器任务）。 */ org.springframework.scheduling.annotation.ScheduledAnnotationBeanPostProcessor 关键类\n/** * Bean post-processor that registers methods annotated with * {@link Scheduled @Scheduled} to be invoked by a * {@link org.springframework.scheduling.TaskScheduler} according to the * \u0026#34;fixedRate\u0026#34;, \u0026#34;fixedDelay\u0026#34;, or \u0026#34;cron\u0026#34; expression provided via the annotation. * * \u0026lt;p\u0026gt;This post-processor is automatically registered by Spring\u0026#39;s * {@code \u0026lt;task:annotation-driven\u0026gt;} XML element, and also by the * {@link EnableScheduling @EnableScheduling} annotation. * * \u0026lt;p\u0026gt;Autodetects any {@link SchedulingConfigurer} instances in the container, * allowing for customization of the scheduler to be used or for fine-grained * control over task registration (e.g. registration of {@link Trigger} tasks). * See the {@link EnableScheduling @EnableScheduling} javadocs for complete usage * details. * * @author Mark Fisher * @author Juergen Hoeller * @author Chris Beams * @author Elizabeth Chatman * @author Victor Brown * @author Sam Brannen * @since 3.0 * @see Scheduled * @see EnableScheduling * @see SchedulingConfigurer * @see org.springframework.scheduling.TaskScheduler * @see org.springframework.scheduling.config.ScheduledTaskRegistrar * @see AsyncAnnotationBeanPostProcessor */ public class ScheduledAnnotationBeanPostProcessor implements ScheduledTaskHolder, MergedBeanDefinitionPostProcessor, DestructionAwareBeanPostProcessor, Ordered, EmbeddedValueResolverAware, BeanNameAware, BeanFactoryAware, ApplicationContextAware, SmartInitializingSingleton, ApplicationListener\u0026lt;ContextRefreshedEvent\u0026gt;, DisposableBean { /** * The default name of the {@link TaskScheduler} bean to pick up: {@value}. * \u0026lt;p\u0026gt;Note that the initial lookup happens by type; this is just the fallback * in case of multiple scheduler beans found in the context. * @since 4.2 */ public static final String DEFAULT_TASK_SCHEDULER_BEAN_NAME = \u0026#34;taskScheduler\u0026#34;; protected final Log logger = LogFactory.getLog(getClass()); private final ScheduledTaskRegistrar registrar; @Nullable private Object scheduler; @Nullable private StringValueResolver embeddedValueResolver; @Nullable private String beanName; @Nullable private BeanFactory beanFactory; @Nullable private ApplicationContext applicationContext; private final Set\u0026lt;Class\u0026lt;?\u0026gt;\u0026gt; nonAnnotatedClasses = Collections.newSetFromMap(new ConcurrentHashMap\u0026lt;\u0026gt;(64)); private final Map\u0026lt;Object, Set\u0026lt;ScheduledTask\u0026gt;\u0026gt; scheduledTasks = new IdentityHashMap\u0026lt;\u0026gt;(16); /** * Create a default {@code ScheduledAnnotationBeanPostProcessor}. */ public ScheduledAnnotationBeanPostProcessor() { this.registrar = new ScheduledTaskRegistrar(); } /** * Create a {@code ScheduledAnnotationBeanPostProcessor} delegating to the * specified {@link ScheduledTaskRegistrar}. * @param registrar the ScheduledTaskRegistrar to register {@code @Scheduled} * tasks on * @since 5.1 */ public ScheduledAnnotationBeanPostProcessor(ScheduledTaskRegistrar registrar) { Assert.notNull(registrar, \u0026#34;ScheduledTaskRegistrar is required\u0026#34;); this.registrar = registrar; } @Override public int getOrder() { return LOWEST_PRECEDENCE; } /** * Set the {@link org.springframework.scheduling.TaskScheduler} that will invoke * the scheduled methods, or a {@link java.util.concurrent.ScheduledExecutorService} * to be wrapped as a TaskScheduler. * \u0026lt;p\u0026gt;If not specified, default scheduler resolution will apply: searching for a * unique {@link TaskScheduler} bean in the context, or for a {@link TaskScheduler} * bean named \u0026#34;taskScheduler\u0026#34; otherwise; the same lookup will also be performed for * a {@link ScheduledExecutorService} bean. If neither of the two is resolvable, * a local single-threaded default scheduler will be created within the registrar. * @see #DEFAULT_TASK_SCHEDULER_BEAN_NAME */ public void setScheduler(Object scheduler) { this.scheduler = scheduler; } @Override public void setEmbeddedValueResolver(StringValueResolver resolver) { this.embeddedValueResolver = resolver; } @Override public void setBeanName(String beanName) { this.beanName = beanName; } /** * Making a {@link BeanFactory} available is optional; if not set, * {@link SchedulingConfigurer} beans won\u0026#39;t get autodetected and * a {@link #setScheduler scheduler} has to be explicitly configured. */ @Override public void setBeanFactory(BeanFactory beanFactory) { this.beanFactory = beanFactory; } /** * Setting an {@link ApplicationContext} is optional: If set, registered * tasks will be activated in the {@link ContextRefreshedEvent} phase; * if not set, it will happen at {@link #afterSingletonsInstantiated} time. */ @Override public void setApplicationContext(ApplicationContext applicationContext) { this.applicationContext = applicationContext; if (this.beanFactory == null) { this.beanFactory = applicationContext; } } @Override public void afterSingletonsInstantiated() { // Remove resolved singleton classes from cache this.nonAnnotatedClasses.clear(); if (this.applicationContext == null) { // Not running in an ApplicationContext -\u0026gt; register tasks early... finishRegistration(); } } @Override public void onApplicationEvent(ContextRefreshedEvent event) { if (event.getApplicationContext() == this.applicationContext) { // Running in an ApplicationContext -\u0026gt; register tasks this late... // giving other ContextRefreshedEvent listeners a chance to perform // their work at the same time (e.g. Spring Batch\u0026#39;s job registration). finishRegistration(); } } /** * 关键的注册逻辑 */ private void finishRegistration() { if (this.scheduler != null) { this.registrar.setScheduler(this.scheduler); } // 解析实现了 SchedulingConfigurer 接口的注册类，编程式任务注册 if (this.beanFactory instanceof ListableBeanFactory) { Map\u0026lt;String, SchedulingConfigurer\u0026gt; beans = ((ListableBeanFactory) this.beanFactory).getBeansOfType(SchedulingConfigurer.class); List\u0026lt;SchedulingConfigurer\u0026gt; configurers = new ArrayList\u0026lt;\u0026gt;(beans.values()); AnnotationAwareOrderComparator.sort(configurers); for (SchedulingConfigurer configurer : configurers) { configurer.configureTasks(this.registrar); } } // 如果注册器中有任务，则注册任务 if (this.registrar.hasTasks() \u0026amp;\u0026amp; this.registrar.getScheduler() == null) { Assert.state(this.beanFactory != null, \u0026#34;BeanFactory must be set to find scheduler by type\u0026#34;); try { // Search for TaskScheduler bean... this.registrar.setTaskScheduler(resolveSchedulerBean(this.beanFactory, TaskScheduler.class, false)); } catch (NoUniqueBeanDefinitionException ex) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Could not find unique TaskScheduler bean - attempting to resolve by name: \u0026#34; + ex.getMessage()); } try { this.registrar.setTaskScheduler(resolveSchedulerBean(this.beanFactory, TaskScheduler.class, true)); } catch (NoSuchBeanDefinitionException ex2) { if (logger.isInfoEnabled()) { logger.info(\u0026#34;More than one TaskScheduler bean exists within the context, and \u0026#34; + \u0026#34;none is named \u0026#39;taskScheduler\u0026#39;. Mark one of them as primary or name it \u0026#39;taskScheduler\u0026#39; \u0026#34; + \u0026#34;(possibly as an alias); or implement the SchedulingConfigurer interface and call \u0026#34; + \u0026#34;ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \u0026#34; + ex.getBeanNamesFound()); } } } catch (NoSuchBeanDefinitionException ex) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Could not find default TaskScheduler bean - attempting to find ScheduledExecutorService: \u0026#34; + ex.getMessage()); } // Search for ScheduledExecutorService bean next... try { this.registrar.setScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, false)); } catch (NoUniqueBeanDefinitionException ex2) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Could not find unique ScheduledExecutorService bean - attempting to resolve by name: \u0026#34; + ex2.getMessage()); } try { this.registrar.setScheduler(resolveSchedulerBean(this.beanFactory, ScheduledExecutorService.class, true)); } catch (NoSuchBeanDefinitionException ex3) { if (logger.isInfoEnabled()) { logger.info(\u0026#34;More than one ScheduledExecutorService bean exists within the context, and \u0026#34; + \u0026#34;none is named \u0026#39;taskScheduler\u0026#39;. Mark one of them as primary or name it \u0026#39;taskScheduler\u0026#39; \u0026#34; + \u0026#34;(possibly as an alias); or implement the SchedulingConfigurer interface and call \u0026#34; + \u0026#34;ScheduledTaskRegistrar#setScheduler explicitly within the configureTasks() callback: \u0026#34; + ex2.getBeanNamesFound()); } } } catch (NoSuchBeanDefinitionException ex2) { if (logger.isTraceEnabled()) { logger.trace(\u0026#34;Could not find default ScheduledExecutorService bean - falling back to default: \u0026#34; + ex2.getMessage()); } // Giving up -\u0026gt; falling back to default scheduler within the registrar... logger.info(\u0026#34;No TaskScheduler/ScheduledExecutorService bean found for scheduled processing\u0026#34;); } } } this.registrar.afterPropertiesSet(); } private \u0026lt;T\u0026gt; T resolveSchedulerBean(BeanFactory beanFactory, Class\u0026lt;T\u0026gt; schedulerType, boolean byName) { if (byName) { T scheduler = beanFactory.getBean(DEFAULT_TASK_SCHEDULER_BEAN_NAME, schedulerType); if (this.beanName != null \u0026amp;\u0026amp; this.beanFactory instanceof ConfigurableBeanFactory) { ((ConfigurableBeanFactory) this.beanFactory).registerDependentBean( DEFAULT_TASK_SCHEDULER_BEAN_NAME, this.beanName); } return scheduler; } else if (beanFactory instanceof AutowireCapableBeanFactory) { NamedBeanHolder\u0026lt;T\u0026gt; holder = ((AutowireCapableBeanFactory) beanFactory).resolveNamedBean(schedulerType); if (this.beanName != null \u0026amp;\u0026amp; beanFactory instanceof ConfigurableBeanFactory) { ((ConfigurableBeanFactory) beanFactory).registerDependentBean(holder.getBeanName(), this.beanName); } return holder.getBeanInstance(); } else { return beanFactory.getBean(schedulerType); } } @Override public void postProcessMergedBeanDefinition(RootBeanDefinition beanDefinition, Class\u0026lt;?\u0026gt; beanType, String beanName) { } @Override public Object postProcessBeforeInitialization(Object bean, String beanName) { return bean; } @Override public Object postProcessAfterInitialization(Object bean, String beanName) { if (bean instanceof AopInfrastructureBean || bean instanceof TaskScheduler || bean instanceof ScheduledExecutorService) { // Ignore AOP infrastructure such as scoped proxies. return bean; } Class\u0026lt;?\u0026gt; targetClass = AopProxyUtils.ultimateTargetClass(bean); if (!this.nonAnnotatedClasses.contains(targetClass) \u0026amp;\u0026amp; AnnotationUtils.isCandidateClass(targetClass, Arrays.asList(Scheduled.class, Schedules.class))) { Map\u0026lt;Method, Set\u0026lt;Scheduled\u0026gt;\u0026gt; annotatedMethods = MethodIntrospector.selectMethods(targetClass, (MethodIntrospector.MetadataLookup\u0026lt;Set\u0026lt;Scheduled\u0026gt;\u0026gt;) method -\u0026gt; { Set\u0026lt;Scheduled\u0026gt; scheduledAnnotations = AnnotatedElementUtils.getMergedRepeatableAnnotations( method, Scheduled.class, Schedules.class); return (!scheduledAnnotations.isEmpty() ? scheduledAnnotations : null); }); if (annotatedMethods.isEmpty()) { this.nonAnnotatedClasses.add(targetClass); if (logger.isTraceEnabled()) { logger.trace(\u0026#34;No @Scheduled annotations found on bean class: \u0026#34; + targetClass); } } else { // Non-empty set of methods annotatedMethods.forEach((method, scheduledAnnotations) -\u0026gt; scheduledAnnotations.forEach(scheduled -\u0026gt; processScheduled(scheduled, method, bean))); if (logger.isTraceEnabled()) { logger.trace(annotatedMethods.size() + \u0026#34; @Scheduled methods processed on bean \u0026#39;\u0026#34; + beanName + \u0026#34;\u0026#39;: \u0026#34; + annotatedMethods); } } } return bean; } /** * Process the given {@code @Scheduled} method declaration on the given bean. * @param scheduled the {@code @Scheduled} annotation * @param method the method that the annotation has been declared on * @param bean the target bean instance * @see #createRunnable(Object, Method) */ protected void processScheduled(Scheduled scheduled, Method method, Object bean) { try { Runnable runnable = createRunnable(bean, method); boolean processedSchedule = false; String errorMessage = \u0026#34;Exactly one of the \u0026#39;cron\u0026#39;, \u0026#39;fixedDelay(String)\u0026#39;, or \u0026#39;fixedRate(String)\u0026#39; attributes is required\u0026#34;; Set\u0026lt;ScheduledTask\u0026gt; tasks = new LinkedHashSet\u0026lt;\u0026gt;(4); // Determine initial delay long initialDelay = convertToMillis(scheduled.initialDelay(), scheduled.timeUnit()); String initialDelayString = scheduled.initialDelayString(); if (StringUtils.hasText(initialDelayString)) { Assert.isTrue(initialDelay \u0026lt; 0, \u0026#34;Specify \u0026#39;initialDelay\u0026#39; or \u0026#39;initialDelayString\u0026#39;, not both\u0026#34;); if (this.embeddedValueResolver != null) { initialDelayString = this.embeddedValueResolver.resolveStringValue(initialDelayString); } if (StringUtils.hasLength(initialDelayString)) { try { initialDelay = convertToMillis(initialDelayString, scheduled.timeUnit()); } catch (RuntimeException ex) { throw new IllegalArgumentException( \u0026#34;Invalid initialDelayString value \\\u0026#34;\u0026#34; + initialDelayString + \u0026#34;\\\u0026#34; - cannot parse into long\u0026#34;); } } } // Check cron expression String cron = scheduled.cron(); if (StringUtils.hasText(cron)) { String zone = scheduled.zone(); if (this.embeddedValueResolver != null) { cron = this.embeddedValueResolver.resolveStringValue(cron); zone = this.embeddedValueResolver.resolveStringValue(zone); } if (StringUtils.hasLength(cron)) { Assert.isTrue(initialDelay == -1, \u0026#34;\u0026#39;initialDelay\u0026#39; not supported for cron triggers\u0026#34;); processedSchedule = true; if (!Scheduled.CRON_DISABLED.equals(cron)) { TimeZone timeZone; if (StringUtils.hasText(zone)) { timeZone = StringUtils.parseTimeZoneString(zone); } else { timeZone = TimeZone.getDefault(); } tasks.add(this.registrar.scheduleCronTask(new CronTask(runnable, new CronTrigger(cron, timeZone)))); } } } // At this point we don\u0026#39;t need to differentiate between initial delay set or not anymore if (initialDelay \u0026lt; 0) { initialDelay = 0; } // Check fixed delay long fixedDelay = convertToMillis(scheduled.fixedDelay(), scheduled.timeUnit()); if (fixedDelay \u0026gt;= 0) { Assert.isTrue(!processedSchedule, errorMessage); processedSchedule = true; tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay))); } String fixedDelayString = scheduled.fixedDelayString(); if (StringUtils.hasText(fixedDelayString)) { if (this.embeddedValueResolver != null) { fixedDelayString = this.embeddedValueResolver.resolveStringValue(fixedDelayString); } if (StringUtils.hasLength(fixedDelayString)) { Assert.isTrue(!processedSchedule, errorMessage); processedSchedule = true; try { fixedDelay = convertToMillis(fixedDelayString, scheduled.timeUnit()); } catch (RuntimeException ex) { throw new IllegalArgumentException( \u0026#34;Invalid fixedDelayString value \\\u0026#34;\u0026#34; + fixedDelayString + \u0026#34;\\\u0026#34; - cannot parse into long\u0026#34;); } tasks.add(this.registrar.scheduleFixedDelayTask(new FixedDelayTask(runnable, fixedDelay, initialDelay))); } } // Check fixed rate long fixedRate = convertToMillis(scheduled.fixedRate(), scheduled.timeUnit()); if (fixedRate \u0026gt;= 0) { Assert.isTrue(!processedSchedule, errorMessage); processedSchedule = true; tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay))); } String fixedRateString = scheduled.fixedRateString(); if (StringUtils.hasText(fixedRateString)) { if (this.embeddedValueResolver != null) { fixedRateString = this.embeddedValueResolver.resolveStringValue(fixedRateString); } if (StringUtils.hasLength(fixedRateString)) { Assert.isTrue(!processedSchedule, errorMessage); processedSchedule = true; try { fixedRate = convertToMillis(fixedRateString, scheduled.timeUnit()); } catch (RuntimeException ex) { throw new IllegalArgumentException( \u0026#34;Invalid fixedRateString value \\\u0026#34;\u0026#34; + fixedRateString + \u0026#34;\\\u0026#34; - cannot parse into long\u0026#34;); } tasks.add(this.registrar.scheduleFixedRateTask(new FixedRateTask(runnable, fixedRate, initialDelay))); } } // Check whether we had any attribute set Assert.isTrue(processedSchedule, errorMessage); // Finally register the scheduled tasks synchronized (this.scheduledTasks) { Set\u0026lt;ScheduledTask\u0026gt; regTasks = this.scheduledTasks.computeIfAbsent(bean, key -\u0026gt; new LinkedHashSet\u0026lt;\u0026gt;(4)); regTasks.addAll(tasks); } } catch (IllegalArgumentException ex) { throw new IllegalStateException( \u0026#34;Encountered invalid @Scheduled method \u0026#39;\u0026#34; + method.getName() + \u0026#34;\u0026#39;: \u0026#34; + ex.getMessage()); } } /** * Create a {@link Runnable} for the given bean instance, * calling the specified scheduled method. * \u0026lt;p\u0026gt;The default implementation creates a {@link ScheduledMethodRunnable}. * @param target the target bean instance * @param method the scheduled method to call * @since 5.1 * @see ScheduledMethodRunnable#ScheduledMethodRunnable(Object, Method) */ protected Runnable createRunnable(Object target, Method method) { Assert.isTrue(method.getParameterCount() == 0, \u0026#34;Only no-arg methods may be annotated with @Scheduled\u0026#34;); Method invocableMethod = AopUtils.selectInvocableMethod(method, target.getClass()); return new ScheduledMethodRunnable(target, invocableMethod); } private static long convertToMillis(long value, TimeUnit timeUnit) { return TimeUnit.MILLISECONDS.convert(value, timeUnit); } private static long convertToMillis(String value, TimeUnit timeUnit) { if (isDurationString(value)) { return Duration.parse(value).toMillis(); } return convertToMillis(Long.parseLong(value), timeUnit); } private static boolean isDurationString(String value) { return (value.length() \u0026gt; 1 \u0026amp;\u0026amp; (isP(value.charAt(0)) || isP(value.charAt(1)))); } private static boolean isP(char ch) { return (ch == \u0026#39;P\u0026#39; || ch == \u0026#39;p\u0026#39;); } /** * Return all currently scheduled tasks, from {@link Scheduled} methods * as well as from programmatic {@link SchedulingConfigurer} interaction. * @since 5.0.2 */ @Override public Set\u0026lt;ScheduledTask\u0026gt; getScheduledTasks() { Set\u0026lt;ScheduledTask\u0026gt; result = new LinkedHashSet\u0026lt;\u0026gt;(); synchronized (this.scheduledTasks) { Collection\u0026lt;Set\u0026lt;ScheduledTask\u0026gt;\u0026gt; allTasks = this.scheduledTasks.values(); for (Set\u0026lt;ScheduledTask\u0026gt; tasks : allTasks) { result.addAll(tasks); } } result.addAll(this.registrar.getScheduledTasks()); return result; } @Override public void postProcessBeforeDestruction(Object bean, String beanName) { Set\u0026lt;ScheduledTask\u0026gt; tasks; synchronized (this.scheduledTasks) { tasks = this.scheduledTasks.remove(bean); } if (tasks != null) { for (ScheduledTask task : tasks) { task.cancel(); } } } @Override public boolean requiresDestruction(Object bean) { synchronized (this.scheduledTasks) { return this.scheduledTasks.containsKey(bean); } } @Override public void destroy() { synchronized (this.scheduledTasks) { Collection\u0026lt;Set\u0026lt;ScheduledTask\u0026gt;\u0026gt; allTasks = this.scheduledTasks.values(); for (Set\u0026lt;ScheduledTask\u0026gt; tasks : allTasks) { for (ScheduledTask task : tasks) { task.cancel(); } } this.scheduledTasks.clear(); } this.registrar.destroy(); } } 第二个关键类\n/** * Helper bean for registering tasks with a {@link TaskScheduler}, typically using cron * expressions. * * \u0026lt;p\u0026gt;As of Spring 3.1, {@code ScheduledTaskRegistrar} has a more prominent user-facing * role when used in conjunction with the {@link * org.springframework.scheduling.annotation.EnableAsync @EnableAsync} annotation and its * {@link org.springframework.scheduling.annotation.SchedulingConfigurer * SchedulingConfigurer} callback interface. * * @author Juergen Hoeller * @author Chris Beams * @author Tobias Montagna-Hay * @author Sam Brannen * @since 3.0 * @see org.springframework.scheduling.annotation.EnableAsync * @see org.springframework.scheduling.annotation.SchedulingConfigurer */ public class ScheduledTaskRegistrar implements ScheduledTaskHolder, InitializingBean, DisposableBean { /** * A special cron expression value that indicates a disabled trigger: {@value}. * \u0026lt;p\u0026gt;This is primarily meant for use with {@link #addCronTask(Runnable, String)} * when the value for the supplied {@code expression} is retrieved from an * external source \u0026amp;mdash; for example, from a property in the * {@link org.springframework.core.env.Environment Environment}. * @since 5.2 * @see org.springframework.scheduling.annotation.Scheduled#CRON_DISABLED */ public static final String CRON_DISABLED = \u0026#34;-\u0026#34;; @Nullable private TaskScheduler taskScheduler; @Nullable private ScheduledExecutorService localExecutor; @Nullable private List\u0026lt;TriggerTask\u0026gt; triggerTasks; @Nullable private List\u0026lt;CronTask\u0026gt; cronTasks; @Nullable private List\u0026lt;IntervalTask\u0026gt; fixedRateTasks; @Nullable private List\u0026lt;IntervalTask\u0026gt; fixedDelayTasks; private final Map\u0026lt;Task, ScheduledTask\u0026gt; unresolvedTasks = new HashMap\u0026lt;\u0026gt;(16); private final Set\u0026lt;ScheduledTask\u0026gt; scheduledTasks = new LinkedHashSet\u0026lt;\u0026gt;(16); /** * Set the {@link TaskScheduler} to register scheduled tasks with. */ public void setTaskScheduler(TaskScheduler taskScheduler) { Assert.notNull(taskScheduler, \u0026#34;TaskScheduler must not be null\u0026#34;); this.taskScheduler = taskScheduler; } /** * Set the {@link TaskScheduler} to register scheduled tasks with, or a * {@link java.util.concurrent.ScheduledExecutorService} to be wrapped as a * {@code TaskScheduler}. */ public void setScheduler(@Nullable Object scheduler) { if (scheduler == null) { this.taskScheduler = null; } else if (scheduler instanceof TaskScheduler) { this.taskScheduler = (TaskScheduler) scheduler; } else if (scheduler instanceof ScheduledExecutorService) { this.taskScheduler = new ConcurrentTaskScheduler(((ScheduledExecutorService) scheduler)); } else { throw new IllegalArgumentException(\u0026#34;Unsupported scheduler type: \u0026#34; + scheduler.getClass()); } } /** * Return the {@link TaskScheduler} instance for this registrar (may be {@code null}). */ @Nullable public TaskScheduler getScheduler() { return this.taskScheduler; } /** * Specify triggered tasks as a Map of Runnables (the tasks) and Trigger objects * (typically custom implementations of the {@link Trigger} interface). */ public void setTriggerTasks(Map\u0026lt;Runnable, Trigger\u0026gt; triggerTasks) { this.triggerTasks = new ArrayList\u0026lt;\u0026gt;(); triggerTasks.forEach((task, trigger) -\u0026gt; addTriggerTask(new TriggerTask(task, trigger))); } /** * Specify triggered tasks as a list of {@link TriggerTask} objects. Primarily used * by {@code \u0026lt;task:*\u0026gt;} namespace parsing. * @since 3.2 * @see ScheduledTasksBeanDefinitionParser */ public void setTriggerTasksList(List\u0026lt;TriggerTask\u0026gt; triggerTasks) { this.triggerTasks = triggerTasks; } /** * Get the trigger tasks as an unmodifiable list of {@link TriggerTask} objects. * @return the list of tasks (never {@code null}) * @since 4.2 */ public List\u0026lt;TriggerTask\u0026gt; getTriggerTaskList() { return (this.triggerTasks != null? Collections.unmodifiableList(this.triggerTasks) : Collections.emptyList()); } /** * Specify triggered tasks as a Map of Runnables (the tasks) and cron expressions. * @see CronTrigger */ public void setCronTasks(Map\u0026lt;Runnable, String\u0026gt; cronTasks) { this.cronTasks = new ArrayList\u0026lt;\u0026gt;(); cronTasks.forEach(this::addCronTask); } /** * Specify triggered tasks as a list of {@link CronTask} objects. Primarily used by * {@code \u0026lt;task:*\u0026gt;} namespace parsing. * @since 3.2 * @see ScheduledTasksBeanDefinitionParser */ public void setCronTasksList(List\u0026lt;CronTask\u0026gt; cronTasks) { this.cronTasks = cronTasks; } /** * Get the cron tasks as an unmodifiable list of {@link CronTask} objects. * @return the list of tasks (never {@code null}) * @since 4.2 */ public List\u0026lt;CronTask\u0026gt; getCronTaskList() { return (this.cronTasks != null ? Collections.unmodifiableList(this.cronTasks) : Collections.emptyList()); } /** * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-rate values. * @see TaskScheduler#scheduleAtFixedRate(Runnable, long) */ public void setFixedRateTasks(Map\u0026lt;Runnable, Long\u0026gt; fixedRateTasks) { this.fixedRateTasks = new ArrayList\u0026lt;\u0026gt;(); fixedRateTasks.forEach(this::addFixedRateTask); } /** * Specify fixed-rate tasks as a list of {@link IntervalTask} objects. Primarily used * by {@code \u0026lt;task:*\u0026gt;} namespace parsing. * @since 3.2 * @see ScheduledTasksBeanDefinitionParser */ public void setFixedRateTasksList(List\u0026lt;IntervalTask\u0026gt; fixedRateTasks) { this.fixedRateTasks = fixedRateTasks; } /** * Get the fixed-rate tasks as an unmodifiable list of {@link IntervalTask} objects. * @return the list of tasks (never {@code null}) * @since 4.2 */ public List\u0026lt;IntervalTask\u0026gt; getFixedRateTaskList() { return (this.fixedRateTasks != null ? Collections.unmodifiableList(this.fixedRateTasks) : Collections.emptyList()); } /** * Specify triggered tasks as a Map of Runnables (the tasks) and fixed-delay values. * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long) */ public void setFixedDelayTasks(Map\u0026lt;Runnable, Long\u0026gt; fixedDelayTasks) { this.fixedDelayTasks = new ArrayList\u0026lt;\u0026gt;(); fixedDelayTasks.forEach(this::addFixedDelayTask); } /** * Specify fixed-delay tasks as a list of {@link IntervalTask} objects. Primarily used * by {@code \u0026lt;task:*\u0026gt;} namespace parsing. * @since 3.2 * @see ScheduledTasksBeanDefinitionParser */ public void setFixedDelayTasksList(List\u0026lt;IntervalTask\u0026gt; fixedDelayTasks) { this.fixedDelayTasks = fixedDelayTasks; } /** * Get the fixed-delay tasks as an unmodifiable list of {@link IntervalTask} objects. * @return the list of tasks (never {@code null}) * @since 4.2 */ public List\u0026lt;IntervalTask\u0026gt; getFixedDelayTaskList() { return (this.fixedDelayTasks != null ? Collections.unmodifiableList(this.fixedDelayTasks) : Collections.emptyList()); } /** * Add a Runnable task to be triggered per the given {@link Trigger}. * @see TaskScheduler#scheduleAtFixedRate(Runnable, long) */ public void addTriggerTask(Runnable task, Trigger trigger) { addTriggerTask(new TriggerTask(task, trigger)); } /** * Add a {@code TriggerTask}. * @since 3.2 * @see TaskScheduler#scheduleAtFixedRate(Runnable, long) */ public void addTriggerTask(TriggerTask task) { if (this.triggerTasks == null) { this.triggerTasks = new ArrayList\u0026lt;\u0026gt;(); } this.triggerTasks.add(task); } /** * Add a {@link Runnable} task to be triggered per the given cron {@code expression}. * \u0026lt;p\u0026gt;As of Spring Framework 5.2, this method will not register the task if the * {@code expression} is equal to {@link #CRON_DISABLED}. */ public void addCronTask(Runnable task, String expression) { if (!CRON_DISABLED.equals(expression)) { addCronTask(new CronTask(task, expression)); } } /** * Add a {@link CronTask}. * @since 3.2 */ public void addCronTask(CronTask task) { if (this.cronTasks == null) { this.cronTasks = new ArrayList\u0026lt;\u0026gt;(); } this.cronTasks.add(task); } /** * Add a {@code Runnable} task to be triggered at the given fixed-rate interval. * @see TaskScheduler#scheduleAtFixedRate(Runnable, long) */ public void addFixedRateTask(Runnable task, long interval) { addFixedRateTask(new IntervalTask(task, interval, 0)); } /** * Add a fixed-rate {@link IntervalTask}. * @since 3.2 * @see TaskScheduler#scheduleAtFixedRate(Runnable, long) */ public void addFixedRateTask(IntervalTask task) { if (this.fixedRateTasks == null) { this.fixedRateTasks = new ArrayList\u0026lt;\u0026gt;(); } this.fixedRateTasks.add(task); } /** * Add a Runnable task to be triggered with the given fixed delay. * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long) */ public void addFixedDelayTask(Runnable task, long delay) { addFixedDelayTask(new IntervalTask(task, delay, 0)); } /** * Add a fixed-delay {@link IntervalTask}. * @since 3.2 * @see TaskScheduler#scheduleWithFixedDelay(Runnable, long) */ public void addFixedDelayTask(IntervalTask task) { if (this.fixedDelayTasks == null) { this.fixedDelayTasks = new ArrayList\u0026lt;\u0026gt;(); } this.fixedDelayTasks.add(task); } /** * Return whether this {@code ScheduledTaskRegistrar} has any tasks registered. * @since 3.2 */ public boolean hasTasks() { return (!CollectionUtils.isEmpty(this.triggerTasks) || !CollectionUtils.isEmpty(this.cronTasks) || !CollectionUtils.isEmpty(this.fixedRateTasks) || !CollectionUtils.isEmpty(this.fixedDelayTasks)); } /** * Calls {@link #scheduleTasks()} at bean construction time. */ @Override public void afterPropertiesSet() { scheduleTasks(); } /** * Schedule all registered tasks against the underlying * {@linkplain #setTaskScheduler(TaskScheduler) task scheduler}. */ @SuppressWarnings(\u0026#34;deprecation\u0026#34;) protected void scheduleTasks() { if (this.taskScheduler == null) { this.localExecutor = Executors.newSingleThreadScheduledExecutor(); this.taskScheduler = new ConcurrentTaskScheduler(this.localExecutor); } if (this.triggerTasks != null) { for (TriggerTask task : this.triggerTasks) { addScheduledTask(scheduleTriggerTask(task)); } } if (this.cronTasks != null) { for (CronTask task : this.cronTasks) { addScheduledTask(scheduleCronTask(task)); } } if (this.fixedRateTasks != null) { for (IntervalTask task : this.fixedRateTasks) { addScheduledTask(scheduleFixedRateTask(task)); } } if (this.fixedDelayTasks != null) { for (IntervalTask task : this.fixedDelayTasks) { addScheduledTask(scheduleFixedDelayTask(task)); } } } private void addScheduledTask(@Nullable ScheduledTask task) { if (task != null) { this.scheduledTasks.add(task); } } /** * Schedule the specified trigger task, either right away if possible * or on initialization of the scheduler. * @return a handle to the scheduled task, allowing to cancel it * @since 4.3 */ @Nullable public ScheduledTask scheduleTriggerTask(TriggerTask task) { ScheduledTask scheduledTask = this.unresolvedTasks.remove(task); boolean newTask = false; if (scheduledTask == null) { scheduledTask = new ScheduledTask(task); newTask = true; } if (this.taskScheduler != null) { scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger()); } else { addTriggerTask(task); this.unresolvedTasks.put(task, scheduledTask); } return (newTask ? scheduledTask : null); } /** * Schedule the specified cron task, either right away if possible * or on initialization of the scheduler. * @return a handle to the scheduled task, allowing to cancel it * (or {@code null} if processing a previously registered task) * @since 4.3 */ @Nullable public ScheduledTask scheduleCronTask(CronTask task) { ScheduledTask scheduledTask = this.unresolvedTasks.remove(task); boolean newTask = false; if (scheduledTask == null) { scheduledTask = new ScheduledTask(task); newTask = true; } if (this.taskScheduler != null) { scheduledTask.future = this.taskScheduler.schedule(task.getRunnable(), task.getTrigger()); } else { addCronTask(task); this.unresolvedTasks.put(task, scheduledTask); } return (newTask ? scheduledTask : null); } /** * Schedule the specified fixed-rate task, either right away if possible * or on initialization of the scheduler. * @return a handle to the scheduled task, allowing to cancel it * (or {@code null} if processing a previously registered task) * @since 4.3 * @deprecated as of 5.0.2, in favor of {@link #scheduleFixedRateTask(FixedRateTask)} */ @Deprecated @Nullable public ScheduledTask scheduleFixedRateTask(IntervalTask task) { FixedRateTask taskToUse = (task instanceof FixedRateTask ? (FixedRateTask) task : new FixedRateTask(task.getRunnable(), task.getInterval(), task.getInitialDelay())); return scheduleFixedRateTask(taskToUse); } /** * Schedule the specified fixed-rate task, either right away if possible * or on initialization of the scheduler. * @return a handle to the scheduled task, allowing to cancel it * (or {@code null} if processing a previously registered task) * @since 5.0.2 */ @Nullable public ScheduledTask scheduleFixedRateTask(FixedRateTask task) { ScheduledTask scheduledTask = this.unresolvedTasks.remove(task); boolean newTask = false; if (scheduledTask == null) { scheduledTask = new ScheduledTask(task); newTask = true; } if (this.taskScheduler != null) { if (task.getInitialDelay() \u0026gt; 0) { Date startTime = new Date(this.taskScheduler.getClock().millis() + task.getInitialDelay()); scheduledTask.future = this.taskScheduler.scheduleAtFixedRate(task.getRunnable(), startTime, task.getInterval()); } else { scheduledTask.future = this.taskScheduler.scheduleAtFixedRate(task.getRunnable(), task.getInterval()); } } else { addFixedRateTask(task); this.unresolvedTasks.put(task, scheduledTask); } return (newTask ? scheduledTask : null); } /** * Schedule the specified fixed-delay task, either right away if possible * or on initialization of the scheduler. * @return a handle to the scheduled task, allowing to cancel it * (or {@code null} if processing a previously registered task) * @since 4.3 * @deprecated as of 5.0.2, in favor of {@link #scheduleFixedDelayTask(FixedDelayTask)} */ @Deprecated @Nullable public ScheduledTask scheduleFixedDelayTask(IntervalTask task) { FixedDelayTask taskToUse = (task instanceof FixedDelayTask ? (FixedDelayTask) task : new FixedDelayTask(task.getRunnable(), task.getInterval(), task.getInitialDelay())); return scheduleFixedDelayTask(taskToUse); } /** * Schedule the specified fixed-delay task, either right away if possible * or on initialization of the scheduler. * @return a handle to the scheduled task, allowing to cancel it * (or {@code null} if processing a previously registered task) * @since 5.0.2 */ @Nullable public ScheduledTask scheduleFixedDelayTask(FixedDelayTask task) { ScheduledTask scheduledTask = this.unresolvedTasks.remove(task); boolean newTask = false; if (scheduledTask == null) { scheduledTask = new ScheduledTask(task); newTask = true; } if (this.taskScheduler != null) { if (task.getInitialDelay() \u0026gt; 0) { Date startTime = new Date(this.taskScheduler.getClock().millis() + task.getInitialDelay()); scheduledTask.future = this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), startTime, task.getInterval()); } else { scheduledTask.future = this.taskScheduler.scheduleWithFixedDelay(task.getRunnable(), task.getInterval()); } } else { addFixedDelayTask(task); this.unresolvedTasks.put(task, scheduledTask); } return (newTask ? scheduledTask : null); } /** * Return all locally registered tasks that have been scheduled by this registrar. * @since 5.0.2 * @see #addTriggerTask * @see #addCronTask * @see #addFixedRateTask * @see #addFixedDelayTask */ @Override public Set\u0026lt;ScheduledTask\u0026gt; getScheduledTasks() { return Collections.unmodifiableSet(this.scheduledTasks); } @Override public void destroy() { for (ScheduledTask task : this.scheduledTasks) { task.cancel(); } if (this.localExecutor != null) { this.localExecutor.shutdownNow(); } } } 拓展应用 ","permalink":"https://www.catguild.cn/posts/spring%E5%AE%9A%E6%97%B6%E4%BB%BB%E5%8A%A1/","summary":"初认识 基本使用 1、添加基本依赖 2、 @EnableScheduling 注解开启定时任务 @Scheduled 注释标注定时任务方法 通过注册ScheduledAnnotationBeanPostProcessor来执行@Scheduled注释的处理。这可以手动完成，或者更方便地通过task:ann","title":"Spring Task定时任务"},{"content":"总览 方式 优点 缺点 @PostConstruct 注解 1、简单直观，只需要在方法上添加注解即可。2、集成度高，与Spring框架紧密结合，适用于需要与其他Spring功能一起使用的场景。 1、不太适合复杂的初始化逻辑，因为它没有提供很多的错误处理机制。2、无法捕获方法内部的受检异常，需要自己处理异常。 InitializingBean 接口 1.提供了更多的初始化时错误处理机制，可以抛出异常，Spring会处理它。 1、需要实现Spring的接口，与Spring紧密耦合，不太适合在非Spring环境中使用。2、只能用于bean级别的初始化。 ApplicationListener 1.可以监听多种事件，不仅限于初始化事件。可以在应用程序启动后执行一些定制逻辑。 1、在监听多个事件时，可能需要编写更多的条件逻辑以区分不同的事件。2、在某些情况下，事件的发生可能会较早，可能会影响到其他组件。 CommandLineRunner 和 ApplicationRunner 1、可以接收应用程序的命令行参数，适用于需要根据参数执行不同初始化逻辑的场景。 1、可能需要在启动脚本中指定额外的参数，增加了一些配置复杂性。2、只能在应用程序启动后执行一次，不适合周期性的初始化操作。 @EventListener 注解 1、可以灵活地监听多种事件，代码结构清晰。 1、如果监听多种事件，需要在方法内部进行事件类型判断。2、对于非Spring事件，可能不太适用。 简单示例 @PostConstruct 注解 您可以使用@PostConstruct注解在Spring Boot中定义一个方法，在该方法中执行初始化逻辑。这个方法会在bean初始化完成后立即执行，但请注意，它仅适用于被Spring容器管理的bean。\nimport org.springframework.stereotype.Component; import javax.annotation.PostConstruct; @Component public class MyInitializer { @PostConstruct public void initialize() { try { // 在这里编写初始化逻辑 // 可能会抛出异常 } catch (Exception e) { // 处理异常，防止传播到Spring容器 } } } 实现InitializingBean 接口 实现InitializingBean接口： InitializingBean接口是Spring框架提供的，它定义了一个afterPropertiesSet方法，您可以在其中编写初始化逻辑。当bean初始化完成后，Spring容器会自动调用这个方法。\nimport org.springframework.beans.factory.InitializingBean; import org.springframework.stereotype.Component; @Component public class MyInitializer implements InitializingBean { @Override public void afterPropertiesSet() throws Exception { // 在这里编写初始化逻辑 } } 实现ApplicationListener接口 使用ApplicationListener： 您可以实现ApplicationListener接口来监听Spring Boot应用程序的事件，并在特定事件发生时执行初始化操作。例如，您可以监听ContextRefreshedEvent事件，它在应用程序上下文刷新（即初始化）完成后触发。\nimport org.springframework.context.ApplicationListener; import org.springframework.context.event.ContextRefreshedEvent; import org.springframework.stereotype.Component; @Component public class MyInitializer implements ApplicationListener\u0026lt;ContextRefreshedEvent\u0026gt; { @Override public void onApplicationEvent(ContextRefreshedEvent event) { // 在这里编写初始化逻辑 } } 实现CommandLineRunner 和 ApplicationRunner接口 您可以使用CommandLineRunner或ApplicationRunner接口来定义在应用程序完全启动后执行的初始化方法。这两个接口都提供了一个run方法，您可以在其中编写初始化逻辑。 使用 CommandLineRunner：\nimport org.springframework.boot.CommandLineRunner; import org.springframework.stereotype.Component; @Component public class MyCommandLineRunner implements CommandLineRunner { @Override public void run(String... args) throws Exception { // 在这里编写初始化逻辑 System.out.println(\u0026#34;应用程序完全启动后执行的初始化方法 - CommandLineRunner\u0026#34;); } } 使用 ApplicationRunner：\nimport org.springframework.boot.ApplicationArguments; import org.springframework.boot.ApplicationRunner; import org.springframework.stereotype.Component; @Component public class MyApplicationRunner implements ApplicationRunner { @Override public void run(ApplicationArguments args) throws Exception { // 在这里编写初始化逻辑 System.out.println(\u0026#34;应用程序完全启动后执行的初始化方法 - ApplicationRunner\u0026#34;); } } ApplicationRunner： ApplicationRunner接口中的run方法接收一个ApplicationArguments对象作为参数，该对象包含应用程序启动时传递的命令行参数。 这种方式适用于需要根据命令行参数或应用程序参数执行初始化逻辑的场景。例如，您可以根据不同的参数初始化不同的部分。 使用这种方式，您可以处理命令行参数，然后根据参数执行适当的初始化操作。 CommandLineRunner： CommandLineRunner接口中的run方法接收一个字符串数组作为参数，这些字符串是应用程序启动时传递的命令行参数。 这种方式适用于需要直接处理命令行参数的场景。与ApplicationRunner相比，它更直接，不需要额外的参数对象。 使用这种方式，您可以处理传递的命令行参数并执行相应的初始化操作。 可以在Spring Boot应用程序中创建多个实现了这些接口的类，每个类都可以在应用程序启动后执行特定的初始化逻辑。可以通过实现Ordered接口或使用@Order注解来控制ApplicationRunner和CommandLineRunner的执行顺序。 @EventListener注解 使用@EventListener注解： 您可以使用@EventListener注解来标记一个方法，该方法将在特定事件发生时被调用。这个方法可以包含初始化逻辑。\nimport org.springframework.context.event.ContextRefreshedEvent; import org.springframework.context.event.EventListener; import org.springframework.stereotype.Component; @Component public class MyInitializer { @EventListener(ContextRefreshedEvent.class) public void onApplicationEvent(ContextRefreshedEvent event) { // 在这里编写初始化逻辑 } } ","permalink":"https://www.catguild.cn/posts/springboot%E5%88%9D%E5%A7%8B%E5%8C%96%E6%96%B9%E6%B3%95/","summary":"总览 方式 优点 缺点 @PostConstruct 注解 1、简单直观，只需要在方法上添加注解即可。2、集成度高，与Spring框架紧密结合，适用于需要与其他Spring功能一起使用的场景。 1、不太适合复杂的初始化逻辑，因为它没有提供很多的错误处理机制。2、无法捕获方法内部的","title":"SpringBoot初始化方法"},{"content":"","permalink":"https://www.catguild.cn/about/","summary":"","title":"关于"},{"content":"CDN 含义 内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。\u0026mdash;引用自维基百科\nCDN 服务 CDN服务类似服务器的租赁服务，这些服务器一般都是CDN服务商的数据中心，这些服务器可以缓存我们的网站资源，类似一种高速缓存。但是我们无法直接登录这些服务器，但是可以设置一些服务商开放出来的数据管理策略，比如\n静态资源压缩，减小资源传输体积，以提高传输速度和带宽利用率，最常见的压缩方案包括gzip和Brotli。 缓存策略，指定缓存的资源及缓存过期时间，以提供响应速度，并且降低了源服务器的访问压力。 安全策略，用以防止链接盗用，一般的CDN服务都是要付费的，可以设置安全策略，来访问其他人来使用你的CDN服务 CDN工作流程 终端访问CDN加速域名 DNS服务解析CNAME记录（实际上就是获取CDN服务商的服务器地址，此时会返回一个里终端最近的服务器地址） 终端去访问DNS服务器返回的目标服务器地址 CDN服务器检查是否存在该资源 4-1. 如果存在则直接返回该资源 4-2. 如果不存在，则前往回源地址或回源host获取该资源，然后将其返回给终端 如何利用好CDN服务 现在我们知道了CDN服务，实际就是在实际的资源机之间加了一个缓冲集群。终端将不再之间访问我们的资源机，而是是访问这个缓冲集群。如果访问到的节点中没有目标资源，该节点才会去资源机去拉取。故，要提高CDN服务的利用，就是要减少这个拉取动作，也可以说是回源率。另一方面，回源是难以避免的，所有提高回源效率，也会优化的访问速度。\n降低回源率：一般就是采用服务商提供的缓存机制，而要利用好缓存，就需要对资源站尽可能的静态化。 提高回源效果：对一些静态资源的访问，进行合并压缩处理，以减少访问次数，资源传输体积；或者提高资源站的带宽（这点可能会比较难，其实CDN的目的就是在带宽不变的前提下提高更快的访问服务） 其实总结起来就是，缓存+减少数据传输量+减少访问次数 而这三条，在CDN服务商提供的缓冲集群能做，在自己的资源机上也能做。这样就能尽可能的加快资源机的资源访问速度。\n参考 Content delivery network - Wikipedia 內容分髮網絡- MBA智库百科 What is a CDN? | How do CDNs work? | Cloudflare CNAME - 百度百科 gzip - 百度百科 HTTP compression\n","permalink":"https://www.catguild.cn/posts/%E5%86%85%E5%AE%B9%E5%88%86%E5%8F%91%E7%BD%91%E7%BB%9Ccnd/","summary":"CDN 含义 内容分发网络（英语：Content Delivery Network或Content Distribution Network，缩写：CDN）是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来","title":"内容分发网络CND"},{"content":" SoulChild随笔记 SoulChild随笔记 ","permalink":"https://www.catguild.cn/links/","summary":"SoulChild随笔记 SoulChild随笔记","title":"友链"},{"content":"爬虫框架 scrapy 1、创建新项目\nscrapy startproject tutorial 2、创建爬虫文件\n# 创建普通模版 scrapy genspider 爬虫名字 爬取的域名（不用协议头） # 创建 crawl spider 模版 scrapy genspider -t crawl 爬虫名字 爬取的域名（不用协议头） 3、启动爬虫\nscrapy crawl 爬虫名字 项目文件结构 项目名字 项目名字 spiders文件夹（存储的是爬虫文件） init 自定义的爬虫文件\t核心功能文件 init items\t定义数据结构的地方\t爬取的数据包含那些 middleware\t中间件\t代理 settings\t配置文件\trobots协议\tua定义等 response的属性和方法 response.text\t获取的是响应的字符串 response.body\t获取的是二进制数据 response.xpath\t可以直接是xpath方法来解析response中的内容 response.extract()\t提取seletor对象的data属性值 response.extract_first()\t提取seletor列表的第一个数据 setting # 需要使用管道，需要打开该设置 ITEM_PIPELINES = { # 管道可以有多个，并有有优先级，值从1-1000，值越小越高 \u0026#39;项目名.pipelines.管道名\u0026#39;: 300 } 下载图片 import urllib.request class DownLoadPipeline: def process_item(self, item, spider): url = item.get(\u0026#39;url\u0026#39;) filename=\u0026#39;http://\u0026#39;+ item.get(\u0026#39;name\u0026#39;)+\u0026#39;.jpg\u0026#39; urllib.request.urlretrieve(url = url, filename = filename) return item 部署 scrapy部署服务器有一套完整的开源项目：scrapy+scrapyd(服务端)+scrapy-client(客户端)+scrapydweb 1、scrapyd(服务端)\n# 官方文档 https://scrapyd.readthedocs.io # 安装 pipenv install scrapyd # 启动 scrapyd # 浏览器访问 http://127.0.0.1:6800 2、scrapy-client scrapy-client它允许我们将本地的scrapy项目打包发送到scrapyd 这个服务端（前提是服务器scrapyd正常运行）\n# 官方文档 https://pypi.org/project/scrapyd-client/ # 安装 pipenv install scrapyd-client 3、scrapydweb（可选）\nScrapydWeb：用于Scrapyd集群管理的Web应用程序，支持Scrapy日志分析和可视化。\n#官方文档 https://github.com/my8100/scrapydweb/blob/master/README_CN.md # 安装 pipenv install scrapydweb # 运行命令 scrapydweb 运行命令scrapydweb，首次启动将会在当前目录下生成配置文件“scrapydweb_settings_v*.py”\n1、更改配置文件 编辑配置文件，将ENABLE_LOGPARSER更改为False\n2、添加访问权限\nSCRAPYD_SERVERS = [ \u0026#39;127.0.0.1:6800\u0026#39;, # \u0026#39;username:password@localhost:6801#group\u0026#39;, (\u0026#39;username\u0026#39;, \u0026#39;password\u0026#39;, \u0026#39;localhost\u0026#39;, \u0026#39;6801\u0026#39;, \u0026#39;group\u0026#39;), ] 3、添加http认证\nENABLE_AUTH = True USERNAME = \u0026#39;username\u0026#39; PASSWORD = \u0026#39;password\u0026#39; 如果启动失败（一般是使用了高版本的python） # 400 错误 APScheduler==3.9.1 # 500 错误 SQLAlchemy\u0026gt;=1.2.15,\u0026lt;1.4.0 ","permalink":"https://www.catguild.cn/category/practical/python/%E7%88%AC%E8%99%AB/","summary":"爬虫框架 scrapy 1、创建新项目 scrapy startproject tutorial 2、创建爬虫文件 # 创建普通模版 scrapy genspider 爬虫名字 爬取的域名（不用协议头） # 创建 crawl spider 模版 scrapy genspider -t crawl 爬虫名字 爬取的域名（不用协议头） 3、启动爬虫 scrapy crawl 爬虫名字 项目文件结构 项目名字 项目名字 spiders文件夹（存储的是爬虫文件","title":"爬虫"},{"content":"线程中断机制 LockSupport类 简介：用于创建锁和其他同步类的基本线程阻塞原语\n该类与使用它的每个线程关联一个许可证（在Semaphore类的意义上）。如果许可证可用，将立即返回park，并在此过程中消费；否则可能会阻止。如果尚未提供许可，则致电unpark获取许可（与Semaphore不同，许可证不会累积，最多只有一个）\n主要api：park与unpark方法，需要成对使用。\npark：除非许可证可用，否则禁用当前线程以进行线程调度。【作用：阻塞线程】\nunaprk：如果给定线程尚不可用，则为其提供许可。【作用：解除阻塞线程】\n底层调用的是unsafe类，\n使用场景：\n线程阻塞唤醒的方法 有3种方式\n1、使用Object中的wait()方法让线程等待，使用Object中的notify()方法唤醒线程\n2、使用JUC包中Condition的await()方法让线程等待，使用signal()方法唤醒线程\n3、 LockSupport类可以阻塞当前线程以及唤醒指定被阻塞线程\n线程等待唤醒机制 ","permalink":"https://www.catguild.cn/category/juc/%E7%BA%BF%E7%A8%8B%E4%B8%AD%E6%96%AD/","summary":"线程中断机制 LockSupport类 简介：用于创建锁和其他同步类的基本线程阻塞原语 该类与使用它的每个线程关联一个许可证（在Semaphore类的意义上）。如果许可证可用，将立即返回park，并在此过程中消费；否则可能会阻止。如果尚未提供许可","title":"线程中断"},{"content":"算法实现 参考\n","permalink":"https://www.catguild.cn/posts/%E9%82%80%E8%AF%B7%E7%A0%81%E5%AE%9E%E7%8E%B0%E6%96%B9%E6%A1%88/","summary":"算法实现 参考","title":"邀请码实现方案"},{"content":"snowflake 分布式id生成算法的有很多种，Twitter的雪花算法（SnowFlake）就是其中经典的一种。\nSnowFlake算法的优点：\n生成ID时不依赖于数据库，完全在内存生成，高性能高可用。 容量大，每秒可生成几百万ID。 SnowFlake算法在同一毫秒内最多可以生成多少个全局唯一ID呢？同一毫秒的ID数量 = 1024 * 4096 = 4194304 所有生成的id按时间趋势递增，后续插入数据库的索引树的时候，性能较高。 整个分布式系统内不会产生重复id（因为有datacenterId和workerId来做区分） SnowFlake算法的缺点：\n依赖于系统时钟的一致性。如果某台机器的系统时钟回拨，有可能造成ID冲突，或者ID乱序。 还有，在启动之前，如果这台机器的系统时间回拨过，那么有可能出现ID重复的危险。 问题？\nworkId 怎么保证唯一？\n可以通过分布式缓存来保存机器ID和workId之间的映射关系。启动的时候访问分布式缓存查询当前机器ID对应的workId，如果查询不到则获取一个并保存到分布式缓存中。 可通过Zookeeper管理workId，免去手动频繁修改集群节点，去配置机器ID的麻烦。 lastTimestamp上次生成ID的时间戳，这个是在内存中，系统时钟回退+重启后呢？无法保证\n目前好像只能流程上控制系统时钟不回退。 41位\n(timestamp - this.twepoch) \u0026lt;\u0026lt; this.timestampLeftShift 超过长整型怎么办？\nthis.twepoch 可以设置当前开始使用系统时的时间，可以保证69年不超 Javascript 无法支持\u0026gt; 53位的数字怎么办？\njs Number被表示为双精度浮点数，最大值为 Number.MAX_SAFE_INTEGER = 2^53-1 BigInt 是 JavaScript 中的一个新的原始数字类型，可以用任意精度表示整数。即使超出 Number 的安全整数范围限制，也可以安全地存储和操作大整数。 要创建一个 BigInt，将 n 作为后缀添加到任何整数文字字面量 BigInt 支持大数，那怎么控制这里用 64bits 长整型，左移溢出会出现问题吗？\n这里不做处理会出现问题，BigInt 可以用任意精度表示整数\n如何处理？\n暂不处理\n此问题本质还是上面的41位时间差问题，69年不超，再长就超了，需要重新设计支持，也可以做溢出提示。 如果想限制为仅64位整数，则必须始终使用强制转换 BigInt.asIntN BigInt.asUintN 只要我们传递 BigInt 超过 64 位整数范围的值（例如，63 位数值 + 1 位符号位），就会发生溢出。 概述 SnowFlake算法生成id的结果是一个64bit大小的整数，它的结构如下图：\n1位，不用。二进制中最高位为1的都是负数，但是我们生成的id一般都使用整数，所以这个最高位固定是0\n41位 ，用来记录时间戳（毫秒）。\n41位可以表示$2^{41}-1$个数字， 如果只用来表示正整数（计算机中正数包含0），可以表示的数值范围是：0 至 $2^{41}-1$，减1是因为可表示的数值范围是从0开始算的，而不是1。 也就是说41位可以表示$2^{41}-1$个毫秒的值，转化成单位年则是$(2^{41}-1) / (1000 * 60 * 60 * 24 * 365) = 69$年 10位 ，用来记录工作机器id。\n可以部署在$2^{10} = 1024$个节点，包括5位datacenterId和5位workerId 5位（bit）可以表示的最大正整数是$2^{5}-1 = 31$，即可以用0、1、2、3、\u0026hellip;.31这32个数字，来表示不同的datecenterId或workerId 12位 ，序列号，用来记录同毫秒内产生的不同id。\n12位（bit）可以表示的最大正整数是$2^{12}-1 = 4095$，即可以用0、1、2、3、\u0026hellip;.4094这4095个数字，来表示同一机器同一时间截（毫秒)内产生的4095个ID序号 由于64bit的整数是long类型，所以SnowFlake算法生成的id就是long来存储的。但这个长度超出 js 最大数范围 Number.MAX_SAFE_INTEGER 了，在js 中实现要使用 BigInt 来表示。\nTalk is cheap, show you the code JS 版本\n代码理解 https://segmentfault.com/a/1190000011282426\n位运算基础 在计算机中，负数的二进制是用补码来表示的。 反码 = 除符号位, 原码其余位取反而得 补码 = 反码 + 1 补码 = （原码 - 1）再取反码 在计算机中无符号数用原码表示, 有符号数用补码表示 补码的意义就是可以拿补码和原码（3的二进制）相加，最终加出一个“溢出的0”\n因此-1的二进制应该这样算：\n00000000 00000000 00000000 00000001 //原码：1的二进制 11111111 11111111 11111111 11111110 //取反码：1的二进制的反码 11111111 11111111 11111111 11111111 //加1：-1的二进制表示（补码） 用位运算计算n个bit能表示的最大数值 const maxWorkerId = -1n ^ (-1n \u0026lt;\u0026lt; 5n) // 利用位运算计算出5位能表示的最大正整数是多少 -1 左移 5，得结果a ：\n11111111 11111111 11111111 11111111 // -1的二进制表示（补码） 11111 11111111 11111111 11111111 11100000 // 高位溢出的不要，低位补0 11111111 11111111 11111111 11100000 // 结果a -1 异或 a ：\n11111111 11111111 11111111 11111111 // -1的二进制表示（补码） ^ 11111111 11111111 11111111 11100000 // 两个操作数的位中，相同则为0，不同则为1 --------------------------------------------------------------------------- 00000000 00000000 00000000 00011111 // 最终结果31 最终结果是31，二进制 00000000 00000000 00000000 00011111 转十进制可以这么算：\n24+23+22+21+20=16+8+4+2+1=31\n用mask防止溢出 this.sequence = (this.sequence + 1n) \u0026amp; this.sequenceMask; // 这段代码通过 `位与` 运算保证计算的结果范围始终是 0-4095 用位运算汇总结果 位或运算，同一位只要有一个是1，则结果为1，否则为0。\n位运算左移超出的溢出部分扔掉，右侧空位则补0。\nreturn ( ((timestamp - this.twepoch) \u0026lt;\u0026lt; this.timestampLeftShift) | // 时间差左移22 (this.dataCenterId \u0026lt;\u0026lt; this.dataCenterIdShift) | // 数据标识id左移 17 (this.workerId \u0026lt;\u0026lt; this.workerIdShift) | // 机器id左移 12 this.sequence ); -------------------- | |简化 \\|/ -------------------- return (la) | (lb) | (lc) | sequence; 数据示例： timestamp: 1505914988849 twepoch: 1288834974657 datacenterId: 17 workerId: 25 sequence: 0 二进制过程 1 | 41 | 5 | 5 | 12 0|0001100 10100010 10111110 10001001 01011100 00| | | //la 0| |10001| | //lb 0| | |1 1001| //lc or 0| | | |‭0000 00000000‬ //sequence ------------------------------------------------------------------------------------------ 0|0001100 10100010 10111110 10001001 01011100 00|10001|1 1001|‭0000 00000000‬ //结果：910499571847892992 支持反推数据 反推机器ID、数据中心ID和创建的时间戳\n机器ID = id \u0026raquo; workerIdShift \u0026amp; ~(-1n \u0026laquo; workerIdBits); 数据中心ID = id \u0026raquo; datacenterIdShift \u0026amp; ~(-1n \u0026laquo; datacenterIdBits); 时间戳 = id \u0026raquo; timestampLeftShift \u0026amp; ~(-1n \u0026laquo; 41n) + twepoch; 参考：\n雪花算法\nTwitter官方原版 用Scala写的 Twitter ID（Snowflake） ID生成器，Twitter的雪花算法（Java） 理解分布式id生成算法SnowFlake BigInt\nBigInt：JavaScript 中的任意精度整数 BigInt: arbitrary-precision integers in JavaScript chrome jsbi ES proposal: BigInt – arbitrary precision integers MDN BigInt 语法 tc39: proposal-bigint Javascript 提案 BigInt 的一些坑 关于限制为仅64位整数，需要特定处理，可以提示数据长度溢出了。\n// 在 console 中测试，溢出怎么办，怎么检查出问题了 var aa = 1n; (aa\u0026lt;\u0026lt;62n).toString(2).padStart(64, 0); (aa\u0026lt;\u0026lt;65n).toString(2).padStart(64, 0); (BigInt.asIntN(64, aa\u0026lt;\u0026lt;62n)).toString(2).padStart(64, 0); (BigInt.asIntN(64, aa\u0026lt;\u0026lt;65n)).toString(2).padStart(64, 0); const max = 2n ** (64n - 1n) - 1n; BigInt.asIntN(64, max); // 有符号数 BigInt.asUintN(64, max); // 无符号数 → 9223372036854775807n BigInt.asIntN(64, max + 1n); new BigInt64Array(4) ","permalink":"https://www.catguild.cn/posts/%E9%9B%AA%E8%8A%B1%E7%AE%97%E6%B3%95/","summary":"snowflake 分布式id生成算法的有很多种，Twitter的雪花算法（SnowFlake）就是其中经典的一种。 SnowFlake算法的优点： 生成ID时不依赖于数据库，完全在内存生成，高性能高可用。 容量大，每秒可生成几百万ID。 SnowFlake算法在同","title":"雪花算法"}]